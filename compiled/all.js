// Generated by CoffeeScript 1.3.3
(function() {
  var Enemy, Entity, FallingThing, Game, Goblin, Player, SpriteImage, World,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Entity = (function() {

    function Entity() {}

    Entity.prototype.render = function() {
      if (!this.dead) {
        this.sprite.draw(this.x, this.y);
        if (this.world.showHitBoxes) {
          this.world.ctx.strokeStyle = "white";
          return this.world.ctx.strokeRect(this.x, this.y, this.width, this.height);
        }
      }
    };

    Entity.prototype.destroy = function() {
      return this.dead = true;
    };

    Entity.prototype.centreOn = function(centreX) {
      return this.x = centreX - (this.width / 2);
    };

    Entity.prototype.centre = function() {
      return this.x + this.width / 2;
    };

    Entity.prototype.isCollidingWith = function(otherEntity) {
      var dir, dx, dy, h, hx, px, py, w, wy;
      w = (this.width + otherEntity.width) / 2;
      h = (this.height + otherEntity.height) / 2;
      dx = (this.x + this.width / 2) - (otherEntity.x + otherEntity.width / 2);
      dy = (this.y + this.height / 2) - (otherEntity.y + otherEntity.height / 2);
      if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
        wy = w * dy;
        hx = h * dx;
        if (wy > hx) {
          if (wy > -hx) {
            dir = "top";
          } else {
            dir = "left";
          }
        } else {
          if (wy > -hx) {
            dir = "right";
          } else {
            dir = "bottom";
          }
        }
        px = w - (dx < 0 ? -dx : dx);
        py = h - (dy < 0 ? -dy : dy);
        return {
          "dir": dir,
          "pv": [(dx < 0 ? -px : px), (dy < 0 ? -py : py)]
        };
      }
      return false;
    };

    return Entity;

  })();

  window.Entity = Entity;

  Game = (function() {

    Game.prototype.FPS = 60;

    function Game() {
      this.reset = __bind(this.reset, this);

      this.toggleShowHitBoxes = __bind(this.toggleShowHitBoxes, this);

      this.setPlayerSpeed = __bind(this.setPlayerSpeed, this);

      this.main = __bind(this.main, this);

      var _this = this;
      this.lastUpdate = Date.now();
      this.keysDown = {};
      $("body").keydown(function(e) {
        var movementKey, normalKey, _ref;
        _this.keysDown[e.keyCode] = true;
        normalKey = !(e.ctrlKey || e.altKey || e.shiftkey || e.metaKey);
        movementKey = (_ref = e.keyCode) === 37 || _ref === 39;
        if (normalKey) {
          e.preventDefault();
          if (!movementKey && _this.world.gameOver()) {
            return _this.world.reset();
          }
        }
      });
      $("body").keyup(function(e) {
        var _ref;
        delete _this.keysDown[e.keyCode];
        if ((_ref = e.keyCode) === 37 || _ref === 39) {
          return e.preventDefault();
        }
      });
      this.world = new World;
    }

    Game.prototype.main = function() {
      var delta;
      delta = Date.now() - this.lastUpdate;
      this.update(delta);
      this.render();
      return this.lastUpdate = Date.now();
    };

    Game.prototype.reactToInput = function(delta) {
      if (37 in this.keysDown) {
        return this.world.player.moveLeft(delta);
      } else if (39 in this.keysDown) {
        return this.world.player.moveRight(delta);
      } else if (82 in this.keysDown) {
        return this.reset();
      } else {
        return this.world.player.moveToCentre(delta);
      }
    };

    Game.prototype.update = function(delta) {
      this.reactToInput(delta);
      return this.world.update(delta);
    };

    Game.prototype.render = function() {
      return this.world.render();
    };

    Game.prototype.run = function() {
      return setInterval(this.main, 1000 / this.FPS);
    };

    Game.prototype.setPlayerSpeed = function(speed) {
      return this.world.playerSpeed = speed;
    };

    Game.prototype.toggleShowHitBoxes = function(state) {
      return this.world.showHitBoxes = state;
    };

    Game.prototype.reset = function() {
      return this.world.reset();
    };

    return Game;

  })();

  window.Game = Game;

  $(function() {
    var Settings, game, gui, playerSpeed, reset, settings, showHitBoxes;
    game = new Game;
    game.run();
    Settings = function() {
      this.reset = function() {
        return game.reset();
      };
      this.playerSpeed = game.world.player.speed;
      return this.showHitBoxes = game.world.showHitBoxes;
    };
    settings = new Settings;
    gui = new dat.GUI();
    playerSpeed = gui.add(settings, 'playerSpeed', .1, 2);
    playerSpeed.onChange(game.setPlayerSpeed);
    showHitBoxes = gui.add(settings, 'showHitBoxes');
    showHitBoxes.onChange(game.toggleShowHitBoxes);
    return reset = gui.add(settings, 'reset');
  });

  Player = (function(_super) {

    __extends(Player, _super);

    function Player(world) {
      this.world = world;
      this.lane = 2;
      this.y = this.world.height;
      this.speed = this.world.playerSpeed || .7;
      this.returnSpeed = this.world.returnSpeed || 1.5;
      this.sprite = new SpriteImage(this.world, "img/player.png");
      this.height = this.sprite.image.height;
      this.width = this.sprite.image.width;
      this.centreOn(this.world.middleOfLane(2));
    }

    Player.prototype.update = function(delta) {
      if (this.world.gameOver()) {
        this.dyingSound.play();
        return this.destroy();
      }
    };

    Player.prototype.leftOfCentre = function() {
      return this.centre() <= this.world.middleOfLane(2);
    };

    Player.prototype.rightOfCentre = function() {
      return this.centre() >= this.world.middleOfLane(2);
    };

    Player.prototype.moveLeft = function(delta) {
      var newPos;
      newPos = this.x - this.speed * delta;
      if (newPos + (this.width / 2) > (this.world.middleOfLane(1)) && this.leftOfCentre()) {
        return this.x = newPos;
      } else if (this.rightOfCentre()) {
        return this.moveToCentre(delta);
      }
    };

    Player.prototype.moveRight = function(delta) {
      var newPos;
      newPos = this.x + this.speed * delta;
      if (newPos + (this.width / 2) < (this.world.middleOfLane(3)) && this.rightOfCentre()) {
        return this.x = newPos;
      } else if (this.leftOfCentre()) {
        return this.moveToCentre(delta);
      }
    };

    Player.prototype.moveToCentre = function(delta) {
      var distanceToMove;
      distanceToMove = this.returnSpeed * delta;
      if (Math.abs(this.distanceFromCentre()) <= distanceToMove) {
        this.centreOn(this.world.middleOfLane(2));
      }
      if (this.distanceFromCentre() > 200) {
        console.log("asdf");
      }
      if (this.distanceFromCentre() > 0) {
        this.x -= this.returnSpeed * delta;
      }
      if (this.distanceFromCentre() < 0) {
        return this.x += this.returnSpeed * delta;
      }
    };

    Player.prototype.distanceFromCentre = function() {
      return this.centre() - (this.world.middleOfLane(2));
    };

    return Player;

  })(Entity);

  window.Player = Player;

  SpriteImage = (function() {

    SpriteImage.prototype.ready = false;

    function SpriteImage(world, url) {
      var image,
        _this = this;
      this.world = world;
      image = new Image;
      image.src = url;
      image.onload = function() {
        return _this.ready = true;
      };
      this.image = image;
    }

    SpriteImage.prototype.draw = function(x, y) {
      if (this.ready) {
        return this.world.ctx.drawImage(this.image, x, y);
      }
    };

    return SpriteImage;

  })();

  window.SpriteImage = SpriteImage;

  World = (function() {

    World.prototype.height = 500;

    World.prototype.width = 500;

    World.prototype.laneLineWidth = 10;

    World.prototype.leftBoundary = 0;

    World.prototype.rightBoundary = 500;

    World.prototype.numLanes = 3;

    World.prototype.lives = 3;

    World.prototype.showHitBoxes = false;

    function World() {
      this.middleOfLane = __bind(this.middleOfLane, this);
      this.elapsedTime = 0;
      this.laneWidth = this.width / this.numLanes;
      this.timeSinceLastThingFell = 2000;
      this.canvas = document.getElementById('game');
      this.canvas.width = 1024;
      this.canvas.height = 860;
      this.ctx = this.canvas.getContext('2d');
      this.ctx.webkitImageSmoothingEnabled = false;
      this.ctx.font = "bold 16pt Arial";
      this.player = new Player(this);
      this.objects = [this.player];
      this.dyingSound = new Audio("audio/dying.wav");
    }

    World.prototype.aliveObjects = function() {
      var object;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.objects;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          if (object.dead !== true) {
            _results.push(object);
          }
        }
        return _results;
      }).call(this);
    };

    World.prototype.reset = function() {
      this.elapsedTime = 0;
      this.timeSinceLastThingFell = 2000;
      this.player = new Player(this);
      this.objects = [this.player];
      return this.lives = 3;
    };

    World.prototype.update = function(delta) {
      var object, _i, _len, _ref, _results;
      if (this.gameOver()) {
        return;
      }
      this.elapsedTime += delta;
      this.timeSinceLastThingFell += delta;
      if (this.timeSinceLastThingFell >= 600) {
        this.objects.push(new FallingThing(this));
        this.timeSinceLastThingFell = 0;
      }
      _ref = this.aliveObjects();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        _results.push(object.update(delta));
      }
      return _results;
    };

    World.prototype.render = function() {
      var object, _i, _len, _ref, _results;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.drawLanes();
      this.drawLives();
      this.drawTimer();
      if (this.gameOver()) {
        return this.promptReplay();
      } else {
        _ref = this.aliveObjects();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          _results.push(object.render());
        }
        return _results;
      }
    };

    World.prototype.gameOver = function() {
      return this.lives <= 0;
    };

    World.prototype.promptReplay = function() {
      return this.ctx.fillText("Press any key to play again", this.width + 50, 120);
    };

    World.prototype.drawLanes = function() {
      var laneHeight, laneX, _results;
      laneHeight = this.height - 50;
      laneX = 0;
      _results = [];
      while (laneX <= this.width) {
        this.ctx.fillStyle = "white";
        this.ctx.fillRect(laneX, 10, this.laneLineWidth, laneHeight);
        _results.push(laneX += this.laneWidth);
      }
      return _results;
    };

    World.prototype.middleOfLane = function(laneNum) {
      return this.laneLineWidth / 2 + (laneNum - 1) * this.laneWidth + this.laneWidth / 2;
    };

    World.prototype.drawLives = function() {
      return this.ctx.fillText(this.lives, this.width + 50, 60);
    };

    World.prototype.drawTimer = function() {
      this.secondsSinceStart = (this.elapsedTime / 1000).toFixed(2);
      return this.ctx.fillText(this.secondsSinceStart, this.width + 50, 90);
    };

    return World;

  })();

  window.World = World;

  Goblin = (function(_super) {

    __extends(Goblin, _super);

    function Goblin() {
      return Goblin.__super__.constructor.apply(this, arguments);
    }

    Goblin.prototype.speed = 3;

    Goblin.prototype.imgFilename = "img/goblin.png";

    return Goblin;

  })(Enemy);

  window.Goblin = Goblin;

  Enemy = (function(_super) {

    __extends(Enemy, _super);

    Enemy.prototype.y = 10;

    Enemy.prototype.speed = 3;

    Enemy.prototype.usedUpALife = false;

    function Enemy(world) {
      this.world = world;
      this.sprite = new SpriteImage(this.world, this.imgFilename);
      this.lostLifeSound = new Audio("audio/lostLife.wav");
      this.height = this.sprite.image.height;
      this.width = this.sprite.image.width;
      this.lane = Math.floor(Math.random() * this.world.numLanes) + 1;
      this.centreOn(this.world.middleOfLane(this.lane));
    }

    Enemy.prototype.update = function(delta) {
      var atPlayersHeight, inSameLaneAsPlayer;
      this.y += delta * this.speed * Math.log(this.world.elapsedTime) / 50;
      atPlayersHeight = this.y + this.height > this.world.player.y;
      inSameLaneAsPlayer = this.lane === this.world.player.lane;
      if (this.isCollidingWith(this.world.player)) {
        this.destroy();
      }
      if (!this.usedUpALife && this.y > this.world.player.y + 30) {
        this.world.lives -= 1;
        if (this.world.gameOver()) {
          this.world.dyingSound.play();
        }
        this.usedUpALife = true;
        return this.lostLifeSound.play();
      }
    };

    return Enemy;

  })(Entity);

  window.Enemy = Enemy;

  FallingThing = (function(_super) {

    __extends(FallingThing, _super);

    FallingThing.prototype.y = 10;

    FallingThing.prototype.speed = 3;

    FallingThing.prototype.usedUpALife = false;

    function FallingThing(world, lane) {
      this.world = world;
      this.lane = lane;
      this.sprite = new SpriteImage(this.world, "orc.png");
      this.lostLifeSound = new Audio("audio/lostLife.wav");
      this.height = this.sprite.image.height;
      this.width = this.sprite.image.width;
      this.lane = Math.floor(Math.random() * this.world.numLanes) + 1;
      this.centreOn(this.world.middleOfLane(this.lane));
    }

    FallingThing.prototype.update = function(delta) {
      var atPlayersHeight, inSameLaneAsPlayer;
      this.y += delta * this.speed * Math.log(this.world.elapsedTime) / 50;
      atPlayersHeight = this.y + this.height > this.world.player.y;
      inSameLaneAsPlayer = this.lane === this.world.player.lane;
      if (this.isCollidingWith(this.world.player)) {
        this.destroy();
      }
      if (!this.usedUpALife && this.y > this.world.player.y + 30) {
        this.world.lives -= 1;
        if (this.world.gameOver()) {
          this.world.dyingSound.play();
        }
        this.usedUpALife = true;
        return this.lostLifeSound.play();
      }
    };

    return FallingThing;

  })(Entity);

  window.FallingThing = FallingThing;

}).call(this);
